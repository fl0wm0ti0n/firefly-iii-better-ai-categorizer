<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Firefly III Better AI Categorizer</title>
    <style>
        body {
            font-family: sans-serif;
            background: lightgray;
        }

        .container {
            max-width: max(80%, 1024px);
            margin: 5% auto;
            padding: 24px;
            background: #FFF;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, .25);
        }

        h1 {
            text-align: center;
        }

        .controls {
            margin-bottom: 2em;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }

        .controls h2 {
            margin-top: 0;
            color: #495057;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .btn-primary {
            background-color: #007bff;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #0056b3;
        }

        .btn-warning {
            background-color: #ffc107;
            border-color: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background-color: #e0a800;
            border-color: #d39e00;
        }

        .btn-success {
            background-color: #28a745;
            border-color: #28a745;
            color: white;
        }

        .btn-success:hover {
            background-color: #218838;
            border-color: #1e7e34;
        }

        .btn-danger {
            background-color: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background-color: #c82333;
            border-color: #bd2130;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .job {
            border: solid 1px;
            border-radius: 5px;
            margin-bottom: 2em;
            padding: 24px;
        }

        .batch-job {
            border: solid 2px #007bff;
            border-radius: 8px;
            margin-bottom: 2em;
            padding: 24px;
            background: #f8f9fa;
        }

        .batch-job.finished {
            border-color: #28a745;
            background: #d4edda;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar-fill {
            height: 100%;
            background-color: #007bff;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin: 10px 0;
        }

        .stat {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
        }

        .errors {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 10px;
        }

        .error-item {
            font-family: monospace;
            font-size: 12px;
            margin-bottom: 5px;
            color: #856404;
        }

        pre {
            padding: 7px;
            background: #eeeeee;
            overflow-x: auto;
        }

        details {
            margin: 10px 0;
        }

        summary {
            cursor: pointer;
            font-weight: bold;
            padding: 5px;
            background: #e9ecef;
            border-radius: 3px;
        }

        summary:hover {
            background: #dee2e6;
        }

        .failed-transaction, .word-mapping {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .failed-transaction {
            border-left: 4px solid #dc3545;
        }

        .word-mapping {
            border-left: 4px solid #28a745;
        }

        .transaction-content, .mapping-content {
            flex: 1;
        }

        .transaction-meta, .mapping-meta {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 5px;
        }

        .transaction-text, .mapping-text {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 12px;
        }

        .mapping-inputs {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-left: auto;
        }

        .mapping-inputs input {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            width: 120px;
        }

        .no-data {
            text-align: center;
            color: #6c757d;
            font-style: italic;
            padding: 20px;
        }

        .category-mapping {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .category-mapping.disabled {
            background: #f8f9fa;
            opacity: 0.7;
        }

        .category-mapping-content {
            flex: 1;
        }

        .category-mapping-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .category-mapping-name {
            font-weight: bold;
            font-size: 16px;
            color: #495057;
        }

        .category-mapping-category {
            background: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }

        .category-mapping-keywords {
            color: #6c757d;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .category-mapping-stats {
            color: #6c757d;
            font-size: 12px;
        }

        .category-mapping-actions {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #28a745;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .collapsible-section {
            border: 1px solid #dee2e6;
            border-radius: 5px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .collapsible-header {
            background: #f8f9fa;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s;
            user-select: none;
        }

        .collapsible-header:hover {
            background: #e9ecef;
        }

        .collapsible-title {
            font-weight: bold;
            color: #495057;
        }

        .collapsible-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .item-count {
            background: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }

        .expand-icon {
            font-size: 14px;
            transition: transform 0.3s;
            color: #6c757d;
        }

        .expand-icon.expanded {
            transform: rotate(180deg);
        }

        .collapsible-content {
            padding: 15px;
            background: white;
            display: none;
        }

        .collapsible-content.expanded {
            display: block;
        }

        .collapsible-content.no-items {
            padding: 20px;
            text-align: center;
            color: #6c757d;
            font-style: italic;
        }

        .foreign-keywords-display {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }

        .foreign-keywords-display .keywords-list {
            word-wrap: break-word;
            line-height: 1.5;
            color: #495057;
        }

        .edit-button {
            background: #6c757d;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 10px;
        }

        .edit-button:hover {
            background: #5a6268;
        }
        
        /* Transaction Management Styles */
        .transaction-list {
            max-height: 600px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 10px;
            background: #f8f9fa;
        }
        
        .transaction-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            margin-bottom: 8px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .transaction-item:hover {
            border-color: #007bff;
            box-shadow: 0 2px 4px rgba(0,123,255,0.1);
        }
        
        .transaction-item.selected {
            background: #e3f2fd;
            border-color: #2196f3;
            box-shadow: 0 2px 8px rgba(33,150,243,0.2);
        }
        
        .transaction-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
            z-index: 1000;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }
        
        .transaction-item.drag-preview {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            transform: rotate(5deg);
            opacity: 0.8;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }
        
        .transaction-checkbox {
            margin: 0;
        }
        
        .transaction-content {
            flex: 1;
            min-width: 0;
        }
        
        .transaction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .transaction-description {
            font-weight: 600;
            color: #2c3e50;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 250px;
        }
        
        .transaction-amount {
            font-weight: bold;
            font-family: monospace;
            font-size: 14px;
        }
        
        .transaction-amount.withdrawal {
            color: #dc3545;
        }
        
        .transaction-amount.deposit {
            color: #28a745;
        }
        
        .transaction-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: #6c757d;
        }
        
        .transaction-destination {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }
        
        .transaction-date {
            color: #8e8e93;
        }
        
        .transaction-category {
            background: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .transaction-type {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .transaction-type.withdrawal {
            background: #fff5f5;
            color: #dc3545;
            border: 1px solid #fdc2c7;
        }
        
        .transaction-type.deposit {
            background: #f0fff4;
            color: #28a745;
            border: 1px solid #c3e6cb;
        }
        
        .btn-small {
            padding: 4px 8px;
            font-size: 11px;
        }
        
        .loading-state, .no-data {
            text-align: center;
            padding: 40px 20px;
            color: #6c757d;
            font-style: italic;
        }
        
        /* Drag and Drop Styles */
        .transaction-list.drag-over {
            border-color: #28a745;
            background: #d4edda;
            box-shadow: inset 0 0 10px rgba(40, 167, 69, 0.2);
        }
        
        .transaction-list.drag-over-invalid {
            border-color: #dc3545;
            background: #f8d7da;
            box-shadow: inset 0 0 10px rgba(220, 53, 69, 0.2);
        }
        
        .drop-zone {
            position: relative;
            border: 2px dashed transparent;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .drop-zone.active {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }
        
        .drop-zone.invalid {
            border-color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }
        
        .drop-zone-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            z-index: 10;
        }
        
        .transaction-list.active .drop-zone-overlay,
        .transaction-list.invalid .drop-zone-overlay {
            display: flex;
        }
        
        .drop-zone-message {
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            font-weight: bold;
            text-align: center;
        }
        
        .transaction-list.active .drop-zone-message {
            color: #28a745;
            border: 2px solid #28a745;
        }
        
        .transaction-list.invalid .drop-zone-message {
            color: #dc3545;
            border: 2px solid #dc3545;
        }
        
        /* Category Selection Styles */
        .category-selection-area {
            position: relative;
        }
        
        .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
            display: none;
        }
        
        .category-grid.show {
            display: grid;
        }
        
        .category-drop-zone {
            padding: 15px;
            background: white;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 500;
            color: #6c757d;
        }
        
        .category-drop-zone:hover {
            border-color: #007bff;
            background: #f0f8ff;
            color: #007bff;
        }
        
        .category-drop-zone.drag-over {
            border-color: #28a745;
            background: #d4edda;
            color: #28a745;
            transform: scale(1.02);
        }
        
        .category-drop-zone.processing {
            border-color: #ffc107;
            background: #fff3cd;
            color: #856404;
        }
        
        .drag-helper {
            position: fixed;
            z-index: 10000;
            pointer-events: none;
            background: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transform: translate(-50%, -50%);
        }
        
        .transaction-item .drag-handle {
            opacity: 0;
            transition: opacity 0.2s ease;
            cursor: grab;
            color: #6c757d;
            font-size: 16px;
            margin-right: 5px;
        }
        
        .transaction-item:hover .drag-handle {
            opacity: 1;
        }
        
        .transaction-item .drag-handle:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Firefly III Better AI Categorizer</h1>
    
    <section class="controls">
        <h2>General Settings</h2>
        <div style="margin-bottom: 15px;">
            <label for="auto-skip-deposits">
                <input type="checkbox" id="auto-skip-deposits" style="margin-right: 8px;">
                Skip Deposits from categorization
            </label>
            <p style="margin: 5px 0 0 0; font-size: 12px; color: #6c757d;">
                <em>When enabled, deposit transactions (salary, refunds, etc.) will be skipped during all categorization processes.</em>
            </p>
        </div>
        <button id="btn-save-general-settings" class="btn btn-success">💾 Save General Settings</button>
    </section>

    <section class="controls">
        <h2>Manual Processing</h2>
        <div class="button-group">
            <button id="btn-process-uncategorized" class="btn btn-primary">
                Process Uncategorized Transactions
            </button>
            <button id="btn-process-all" class="btn btn-warning">
                Process All Transactions (Overwrite Categories)
            </button>
        </div>
        <p><small>
            <strong>Process Uncategorized:</strong> Categorizes only transactions without existing categories.<br>
            <strong>Process All:</strong> Re-categorizes ALL transactions (withdrawals and deposits), overwriting existing categories.
        </small></p>
    </section>

    <section class="controls">
        <h2>Test Webhook (Live Mode)</h2>
        <div class="test-form">
            <div style="margin-bottom: 10px;">
                <label for="test-description">Transaction Description:</label>
                <input type="text" id="test-description" placeholder="e.g. Purchase at Amazon" 
                       value="Test transaction - Purchase at Amazon" style="width: 100%; padding: 5px; margin-top: 5px;">
            </div>
            <div style="margin-bottom: 10px;">
                <label for="test-destination">Destination Name:</label>
                <input type="text" id="test-destination" placeholder="e.g. Amazon.com" 
                       value="Amazon.com" style="width: 100%; padding: 5px; margin-top: 5px;">
            </div>
            <div style="margin-bottom: 10px;">
                <label for="test-type">Transaction Type:</label>
                <select id="test-type" style="width: 100%; padding: 5px; margin-top: 5px;">
                    <option value="withdrawal">Withdrawal</option>
                    <option value="deposit">Deposit</option>
                </select>
            </div>
            <button id="btn-test-webhook" class="btn btn-success">
                🧪 Test Webhook Categorization
            </button>
        </div>
        <p><small>
            <strong>Test Webhook:</strong> Simulates a Firefly III webhook call to test the AI categorization without creating real transactions.
        </small></p>
    </section>

    <section>
        <h2>Batch Jobs</h2>
        <div id="batch-mount"></div>
    </section>

    <section class="controls">
        <h2>Word Mappings & Failed Transactions</h2>
        
        <div style="margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3>Failed Transactions</h3>
                <div style="display: flex; gap: 10px;">
                    <button id="btn-cleanup-failed" class="btn btn-warning">🧹 Cleanup</button>
                    <button id="btn-refresh-failed" class="btn btn-primary">🔄 Refresh</button>
                </div>
            </div>
            
            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleCollapsible('failed-transactions-content')">
                    <span class="collapsible-title">Failed Transactions</span>
                    <div class="collapsible-info">
                        <span id="failed-transactions-count" class="item-count">0</span>
                        <span class="expand-icon">🔽</span>
                    </div>
                </div>
                <div id="failed-transactions-content" class="collapsible-content">
                    <div id="failed-transactions"></div>
                </div>
            </div>
        </div>

        <div style="margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3>Word Mappings</h3>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="mapping-from" placeholder="Original word/phrase" style="padding: 6px; width: 140px;">
                    <input type="text" id="mapping-to" placeholder="Replacement word/phrase" style="padding: 6px; width: 140px;">
                    <button id="btn-add-mapping" class="btn btn-success btn-small">➕ Add</button>
                </div>
            </div>
            
            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleCollapsible('word-mappings-content')">
                    <span class="collapsible-title">Word Mappings</span>
                    <div class="collapsible-info">
                        <span id="word-mappings-count" class="item-count">0</span>
                        <span class="expand-icon">🔽</span>
                    </div>
                </div>
                <div id="word-mappings-content" class="collapsible-content">
                    <div id="word-mappings"></div>
                </div>
            </div>
        </div>
    </section>

    <section class="controls">
        <h2>Auto-Categorization (Foreign/Travel Detection)</h2>
        
        <div style="margin-bottom: 20px;">
            <h3>Configuration</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label for="auto-enabled">Enable Auto-Categorization:</label>
                    <input type="checkbox" id="auto-enabled" style="margin-left: 10px;">
                </div>
                <div>
                    <label for="auto-native-currency">Native Currency:</label>
                    <input type="text" id="auto-native-currency" placeholder="EUR" style="width: 100%; padding: 5px; margin-top: 5px;">
                </div>
                <div>
                    <label for="auto-home-country">Home Country:</label>
                    <input type="text" id="auto-home-country" placeholder="Austria" style="width: 100%; padding: 5px; margin-top: 5px;">
                </div>
                <div>
                    <label for="auto-foreign-category">Foreign/Travel Category:</label>
                    <input type="text" id="auto-foreign-category" placeholder="Travel & Foreign" style="width: 100%; padding: 5px; margin-top: 5px;">
                </div>
            </div>
            <button id="btn-save-auto-config" class="btn btn-success">💾 Save Configuration</button>
        </div>


        <div style="margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3>Foreign Keywords</h3>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="foreign-keywords-input" placeholder="e.g. bangkok, hotel, usd, paris, london" style="padding: 6px; width: 300px;">
                    <button id="btn-save-foreign-keywords" class="btn btn-success btn-small">💾 Save Keywords</button>
                </div>
            </div>
            
            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleCollapsible('foreign-keywords-content')">
                    <span class="collapsible-title">Foreign Keywords</span>
                    <div class="collapsible-info">
                        <span id="foreign-keywords-count" class="item-count">0</span>
                        <span class="expand-icon">🔽</span>
                    </div>
                </div>
                <div id="foreign-keywords-content" class="collapsible-content">
                    <div id="foreign-keywords"></div>
                </div>
            </div>
        </div>

        <div style="background: #e7f3ff; padding: 15px; border-radius: 5px; border-left: 4px solid #007bff;">
            <strong>ℹ️ How it works:</strong>
            <ul style="margin: 10px 0; padding-left: 20px;">
                <li><strong>Currency Check:</strong> Non-native currencies are auto-categorized</li>
                <li><strong>Foreign Flag:</strong> Firefly's foreign transactions are auto-categorized</li>
                <li><strong>Keywords:</strong> Foreign places, travel terms, and international brands trigger auto-categorization</li>
                <li><strong>Countries:</strong> Foreign country names in transaction text trigger auto-categorization</li>
            </ul>
            <small><em>Auto-categorization runs BEFORE AI processing, saving OpenAI API calls for obvious foreign/travel transactions.</em></small>
        </div>
    </section>

    <section class="controls">
        <h2>Category Mappings (Custom Rules)</h2>
        
        <div style="margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3>Your Category Rules</h3>
                <button id="btn-add-category-mapping" class="btn btn-success">➕ Add New Category Mapping</button>
            </div>
            
            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleCollapsible('category-mappings-content')">
                    <span class="collapsible-title">Category Mappings</span>
                    <div class="collapsible-info">
                        <span id="category-mappings-count" class="item-count">0</span>
                        <span class="expand-icon">🔽</span>
                    </div>
                </div>
                <div id="category-mappings-content" class="collapsible-content">
                    <div id="category-mappings-list"></div>
                </div>
            </div>
            
            <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; border-left: 4px solid #28a745; margin-bottom: 20px;">
                <strong>💡 How to use:</strong>
                <ul style="margin: 10px 0; padding-left: 20px;">
                    <li><strong>Name:</strong> Descriptive name for the rule (e.g. "Supermarkets")</li>
                    <li><strong>Category:</strong> Firefly category (must exist, e.g. "Groceries")</li>
                    <li><strong>Keywords:</strong> Comma-separated search terms (e.g. "rewe, spar, hofer, billa")</li>
                    <li><strong>Priority:</strong> Category Mappings are checked BEFORE Auto-Categorization and AI</li>
                </ul>
                <small><em>Examples: "shell, bp, esso" → "Transportation" | "pharmacy, doctor, dentist" → "Healthcare"</em></small>
            </div>

            <!-- Add Category Mapping Form (initially hidden) -->
            <div id="add-category-mapping-form" style="display: none; background: #f8f9fa; padding: 20px; border-radius: 5px; border: 1px solid #dee2e6; margin-bottom: 20px;">
                <h4>Add New Category Mapping</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label for="mapping-name">Mapping Name:</label>
                        <input type="text" id="mapping-name" placeholder="e.g. Supermarkets" style="width: 100%; padding: 8px; margin-top: 5px;">
                    </div>
                    <div>
                        <label for="mapping-target-category">Target Category:</label>
                        <input type="text" id="mapping-target-category" placeholder="e.g. Groceries" style="width: 100%; padding: 8px; margin-top: 5px;">
                    </div>
                </div>
                <div style="margin-bottom: 15px;">
                    <label for="mapping-keywords">Keywords (comma separated):</label>
                    <input type="text" id="mapping-keywords" placeholder="e.g. rewe, spar, hofer, billa" style="width: 100%; padding: 8px; margin-top: 5px;">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button id="btn-save-category-mapping" class="btn btn-success">💾 Save Mapping</button>
                    <button id="btn-cancel-category-mapping" class="btn btn-warning">❌ Cancel</button>
                </div>
            </div>
        </div>
    </section>

    <section class="controls">
        <h2>Transaction Management (Interactive)</h2>
        
        <div style="margin-bottom: 20px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label for="transaction-type-filter">Transaction Type:</label>
                    <select id="transaction-type-filter" style="width: 100%; padding: 8px; margin-top: 5px;">
                        <option value="all">All Transactions</option>
                        <option value="withdrawal">Withdrawals Only</option>
                        <option value="deposit">Deposits Only</option>
                        <option value="uncategorized">Uncategorized Only</option>
                    </select>
                </div>
                <div>
                    <label for="category-filter">Category Filter:</label>
                    <select id="category-filter" style="width: 100%; padding: 8px; margin-top: 5px;">
                        <option value="all">All Categories</option>
                        <option value="yes">Has Category</option>
                        <option value="no">No Category</option>
                    </select>
                </div>
                <div>
                    <label for="specific-category-filter">Specific Category:</label>
                    <select id="specific-category-filter" style="width: 100%; padding: 8px; margin-top: 5px;">
                        <option value="">Select Category...</option>
                    </select>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label for="search-text">Search (Description/Destination):</label>
                    <input type="text" id="search-text" placeholder="e.g. Amazon, Supermarket, Hotel..." 
                           style="width: 100%; padding: 8px; margin-top: 5px;">
                </div>
                <div>
                    <label for="date-from">Date From:</label>
                    <input type="date" id="date-from" 
                           style="width: 100%; padding: 8px; margin-top: 5px;">
                </div>
                <div>
                    <label for="date-to">Date To:</label>
                    <input type="date" id="date-to" 
                           style="width: 100%; padding: 8px; margin-top: 5px;">
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                <div>
                    <label for="min-amount">Min Amount:</label>
                    <input type="number" id="min-amount" placeholder="0.00" step="0.01"
                           style="width: 100%; padding: 8px; margin-top: 5px;">
                </div>
                <div>
                    <label for="max-amount">Max Amount:</label>
                    <input type="number" id="max-amount" placeholder="999.99" step="0.01"
                           style="width: 100%; padding: 8px; margin-top: 5px;">
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; align-items: center;">
                <button id="btn-load-transactions" class="btn btn-primary">🔍 Load Transactions</button>
                <button id="btn-clear-filters" class="btn btn-warning">🗑️ Clear Filters</button>
                <span id="transaction-count" style="margin-left: 20px; font-weight: bold; color: #007bff;"></span>
            </div>
            
            <div style="margin-top: 10px;">
                <small style="color: #6c757d; font-style: italic;">
                    💡 <strong>Date Filter:</strong> Defaults to current month | <strong>Categories:</strong> Available immediately for filtering
                </small>
            </div>
        </div>

        <!-- Two-Column Layout -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
            
            <!-- Left Column: Uncategorized or All Transactions -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3 id="left-column-title">Uncategorized Transactions</h3>
                    <div style="display: flex; gap: 5px; align-items: center;">
                        <button id="btn-select-all-left" class="btn btn-success btn-small">☑️ Select All</button>
                        <button id="btn-deselect-all-left" class="btn btn-warning btn-small">☐ Deselect All</button>
                    </div>
                </div>
                
                <div style="margin-bottom: 10px; display: flex; gap: 10px; align-items: center;">
                    <select id="assign-category-select" style="flex: 1; padding: 6px;">
                        <option value="">Select category to assign...</option>
                    </select>
                    <button id="btn-assign-category" class="btn btn-success">➡️ Assign Category</button>
                </div>
                
                <div id="uncategorized-transactions" class="transaction-list drop-zone">
                    <div class="drop-zone-overlay">
                        <div class="drop-zone-message">
                            Drop here to remove category
                        </div>
                    </div>
                    <div class="no-data">Click "Load Transactions" to begin</div>
                </div>
            </div>
            
            <!-- Right Column: Categorized Transactions -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h3>Categorized Transactions</h3>
                    <div style="display: flex; gap: 5px; align-items: center;">
                        <select id="view-category-select" style="padding: 6px; width: 200px;">
                            <option value="">View all categories...</option>
                        </select>
                        <button id="btn-select-all-right" class="btn btn-success btn-small">☑️ Select All</button>
                        <button id="btn-deselect-all-right" class="btn btn-warning btn-small">☐ Deselect All</button>
                    </div>
                </div>
                
                <div style="margin-bottom: 10px; display: flex; gap: 10px; align-items: center;">
                    <select id="reassign-category-select" style="flex: 1; padding: 6px;">
                        <option value="">Select new category...</option>
                    </select>
                    <button id="btn-reassign-category" class="btn btn-primary">🔄 Reassign</button>
                    <button id="btn-remove-category" class="btn btn-danger">❌ Remove Category</button>
                </div>
                
                <div id="categorized-transactions" class="transaction-list drop-zone">
                    <div class="drop-zone-overlay">
                        <div class="drop-zone-message">
                            Drop here to assign current category
                        </div>
                    </div>
                    <div class="no-data">Select a category to view transactions</div>
                </div>
            </div>
        </div>
        
        <!-- Category Selection Area (appears during drag) -->
        <div class="category-selection-area">
            <div id="category-grid" class="category-grid">
                <!-- Categories will be populated here during drag -->
            </div>
        </div>
        
        <div style="background: #e7f3ff; padding: 15px; border-radius: 5px; border-left: 4px solid #007bff; margin-top: 20px;">
            <strong>💡 How to use:</strong>
            <ul style="margin: 10px 0; padding-left: 20px;">
                <li><strong>Filter & Search:</strong> Use filters to find specific transactions</li>
                <li><strong>Multi-Select:</strong> Check multiple transactions to assign/remove categories in bulk</li>
                <li><strong>Left Column:</strong> Shows uncategorized transactions or filtered results</li>
                <li><strong>Right Column:</strong> Shows transactions from a specific category</li>
                <li><strong>Drag & Drop:</strong> 🖱️ Drag transactions to category zones or between columns</li>
            </ul>
        </div>
    </section>

    <section>
        <h2>Individual Jobs</h2>
        <div id="mount"></div>
    </section>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
    let socket = io();

    const mount = document.getElementById('mount');
    const batchMount = document.getElementById('batch-mount');
    const btnProcessUncategorized = document.getElementById('btn-process-uncategorized');
    const btnProcessAll = document.getElementById('btn-process-all');
    const btnTestWebhook = document.getElementById('btn-test-webhook');
    const btnSaveGeneralSettings = document.getElementById('btn-save-general-settings');
    const testDescription = document.getElementById('test-description');
    const testDestination = document.getElementById('test-destination');
    const testType = document.getElementById('test-type');

    // Word mapping elements
    const btnRefreshFailed = document.getElementById('btn-refresh-failed');
    const btnCleanupFailed = document.getElementById('btn-cleanup-failed');
    const btnAddMapping = document.getElementById('btn-add-mapping');
    const mappingFrom = document.getElementById('mapping-from');
    const mappingTo = document.getElementById('mapping-to');
    const failedTransactionsDiv = document.getElementById('failed-transactions');
    const wordMappingsDiv = document.getElementById('word-mappings');

    // Auto-categorization elements
    const autoEnabled = document.getElementById('auto-enabled');
    const autoSkipDeposits = document.getElementById('auto-skip-deposits');
    const autoNativeCurrency = document.getElementById('auto-native-currency');
    const autoHomeCountry = document.getElementById('auto-home-country');
    const autoForeignCategory = document.getElementById('auto-foreign-category');
    const btnSaveAutoConfig = document.getElementById('btn-save-auto-config');
    const foreignKeywordsInput = document.getElementById('foreign-keywords-input');
    const btnSaveForeignKeywords = document.getElementById('btn-save-foreign-keywords');
    const foreignKeywordsDiv = document.getElementById('foreign-keywords');

    // Category mapping elements
    const btnAddCategoryMapping = document.getElementById('btn-add-category-mapping');
    const addCategoryMappingForm = document.getElementById('add-category-mapping-form');
    const btnSaveCategoryMapping = document.getElementById('btn-save-category-mapping');
    const btnCancelCategoryMapping = document.getElementById('btn-cancel-category-mapping');
    const mappingName = document.getElementById('mapping-name');
    const mappingTargetCategory = document.getElementById('mapping-target-category');
    const mappingKeywords = document.getElementById('mapping-keywords');
    const categoryMappingsList = document.getElementById('category-mappings-list');

    // Button event listeners
    btnProcessUncategorized.addEventListener('click', async () => {
        if (confirm('Start processing all uncategorized transactions?')) {
            btnProcessUncategorized.disabled = true;
            try {
                const response = await fetch('/api/process-uncategorized', { method: 'POST' });
                const result = await response.json();
                if (!result.success) {
                    alert('Error: ' + result.error);
                    btnProcessUncategorized.disabled = false;
                }
            } catch (error) {
                alert('Error: ' + error.message);
                btnProcessUncategorized.disabled = false;
            }
        }
    });

    btnProcessAll.addEventListener('click', async () => {
        if (confirm('WARNING: This will re-categorize ALL transactions and overwrite existing categories. Continue?')) {
            btnProcessAll.disabled = true;
            try {
                const response = await fetch('/api/process-all', { method: 'POST' });
                const result = await response.json();
                if (!result.success) {
                    alert('Error: ' + result.error);
                    btnProcessAll.disabled = false;
                }
            } catch (error) {
                alert('Error: ' + error.message);
                btnProcessAll.disabled = false;
            }
        }
    });

    btnTestWebhook.addEventListener('click', async () => {
        const description = testDescription.value.trim();
        const destination = testDestination.value.trim();
        const type = testType.value.trim();
        
        if (!description || !destination || !type) {
            alert('Please fill in all fields');
            return;
        }
        
        btnTestWebhook.disabled = true;
        btnTestWebhook.textContent = '🧪 Testing...';
        
        try {
            const response = await fetch('/api/test-webhook', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    description: description,
                    destination_name: destination,
                    transaction_type: type
                })
            });
            
            const result = await response.json();
            if (result.success) {
                alert(`Test webhook processed! 
Transaction: "${result.test_data.description}" 
Destination: "${result.test_data.destination_name}"
ID: ${result.test_data.transaction_id}

Check the individual jobs section below to see the categorization result.`);
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            alert('Error: ' + error.message);
        } finally {
            btnTestWebhook.disabled = false;
            btnTestWebhook.textContent = '🧪 Test Webhook Categorization';
        }
    });

    // Word mapping event listeners
    btnRefreshFailed.addEventListener('click', loadFailedTransactions);
    btnCleanupFailed.addEventListener('click', cleanupFailedTransactions);
    btnAddMapping.addEventListener('click', addWordMapping);
    
    // Load data on page load
    loadWordMappings();
    loadFailedTransactions();

    // Auto-categorization event listeners
    btnSaveAutoConfig.addEventListener('click', saveAutoCategorizationConfig);
    btnSaveForeignKeywords.addEventListener('click', saveForeignKeywords);
    btnSaveGeneralSettings.addEventListener('click', saveGeneralSettings);
    
    // Load auto-categorization config on page load
    loadAutoCategorizationConfig();

    // Category mapping event listeners
    btnAddCategoryMapping.addEventListener('click', showAddCategoryMappingForm);
    btnSaveCategoryMapping.addEventListener('click', saveCategoryMapping);
    btnCancelCategoryMapping.addEventListener('click', hideAddCategoryMappingForm);
    
    // Load category mappings on page load
    loadCategoryMappings();

    // Initialize collapsible interface
    setTimeout(() => {
        updateCollapsibleCounts();
        
        console.log('Collapsible interface initialized and tested');
    }, 100);

    // Initialize transaction management safely
    setTimeout(() => {
        try {
            initializeTransactionManagement();
            setDefaultDateFilters();
            loadCategoriesForFilters();
        } catch (error) {
            console.error('Transaction management initialization failed:', error);
        }
    }, 200);

    function setDefaultDateFilters() {
        const now = new Date();
        const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
        const lastDayOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        
        dateFrom.value = firstDayOfMonth.toISOString().split('T')[0];
        dateTo.value = lastDayOfMonth.toISOString().split('T')[0];
    }
    
    async function loadCategoriesForFilters() {
        try {
            const response = await fetch('/api/transactions/list?limit=1');
            const result = await response.json();
            
            if (result.success && result.categories) {
                availableCategories = result.categories;
                populateCategoryDropdowns();
            }
        } catch (error) {
            console.error('Error loading categories for filters:', error);
        }
    }

    // Transaction Management Variables
    let allTransactions = [];
    let leftColumnTransactions = [];
    let rightColumnTransactions = [];
    let availableCategories = [];
    let selectedLeftTransactions = new Set();
    let selectedRightTransactions = new Set();
    
    // Transaction Management Elements
    const transactionTypeFilter = document.getElementById('transaction-type-filter');
    const categoryFilter = document.getElementById('category-filter');
    const specificCategoryFilter = document.getElementById('specific-category-filter');
    const searchText = document.getElementById('search-text');
    const minAmount = document.getElementById('min-amount');
    const maxAmount = document.getElementById('max-amount');
    const dateFrom = document.getElementById('date-from');
    const dateTo = document.getElementById('date-to');
    const btnLoadTransactions = document.getElementById('btn-load-transactions');
    const btnClearFilters = document.getElementById('btn-clear-filters');
    const transactionCount = document.getElementById('transaction-count');
    
    const leftColumnTitle = document.getElementById('left-column-title');
    const uncategorizedTransactionsList = document.getElementById('uncategorized-transactions');
    const categorizedTransactionsList = document.getElementById('categorized-transactions');
    
    const btnSelectAllLeft = document.getElementById('btn-select-all-left');
    const btnDeselectAllLeft = document.getElementById('btn-deselect-all-left');
    const btnSelectAllRight = document.getElementById('btn-select-all-right');
    const btnDeselectAllRight = document.getElementById('btn-deselect-all-right');
    
    const assignCategorySelect = document.getElementById('assign-category-select');
    const btnAssignCategory = document.getElementById('btn-assign-category');
    const viewCategorySelect = document.getElementById('view-category-select');
    const reassignCategorySelect = document.getElementById('reassign-category-select');
    const btnReassignCategory = document.getElementById('btn-reassign-category');
    const btnRemoveCategory = document.getElementById('btn-remove-category');
    
    // Transaction Management Event Listeners
    btnLoadTransactions.addEventListener('click', loadTransactions);
    btnClearFilters.addEventListener('click', clearFilters);
    btnSelectAllLeft.addEventListener('click', () => selectAllTransactions('left'));
    btnDeselectAllLeft.addEventListener('click', () => deselectAllTransactions('left'));
    btnSelectAllRight.addEventListener('click', () => selectAllTransactions('right'));
    btnDeselectAllRight.addEventListener('click', () => deselectAllTransactions('right'));
    btnAssignCategory.addEventListener('click', assignCategoryToSelected);
    btnReassignCategory.addEventListener('click', reassignCategoryToSelected);
    btnRemoveCategory.addEventListener('click', removeCategoryFromSelected);
    viewCategorySelect.addEventListener('change', loadCategorizedTransactions);
    
    // Initialize transaction management

    async function initializeTransactionManagement() {
        // Categories are now loaded separately in loadCategoriesForFilters()
        console.log('Transaction management initialized');
    }
    
    function populateCategoryDropdowns() {
        // Clear existing options (keep default)
        specificCategoryFilter.innerHTML = '<option value="">Select Category...</option>';
        assignCategorySelect.innerHTML = '<option value="">Select category to assign...</option>';
        reassignCategorySelect.innerHTML = '<option value="">Select new category...</option>';
        viewCategorySelect.innerHTML = '<option value="">View all categories...</option>';
        
        // Add categories to dropdowns
        availableCategories.forEach(category => {
            const option1 = new Option(category, category);
            const option2 = new Option(category, category);
            const option3 = new Option(category, category);
            const option4 = new Option(category, category);
            
            specificCategoryFilter.appendChild(option1);
            assignCategorySelect.appendChild(option2);
            reassignCategorySelect.appendChild(option3);
            viewCategorySelect.appendChild(option4);
        });
    }
    
    async function loadTransactions() {
        btnLoadTransactions.disabled = true;
        btnLoadTransactions.textContent = '⏳ Loading...';
        
        uncategorizedTransactionsList.innerHTML = '<div class="loading-state">Loading transactions...</div>';
        
        try {
            const params = new URLSearchParams({
                type: transactionTypeFilter.value,
                hasCategory: categoryFilter.value,
                limit: 500
            });
            
            if (specificCategoryFilter.value) {
                params.append('categoryName', specificCategoryFilter.value);
            }
            
            if (searchText.value.trim()) {
                params.append('searchText', searchText.value.trim());
            }
            
            if (minAmount.value) {
                params.append('minAmount', minAmount.value);
            }
            
            if (maxAmount.value) {
                params.append('maxAmount', maxAmount.value);
            }
            
            if (dateFrom.value) {
                params.append('dateFrom', dateFrom.value);
            }
            
            if (dateTo.value) {
                params.append('dateTo', dateTo.value);
            }
            
            const response = await fetch(`/api/transactions/filter?${params}`);
            const result = await response.json();
            
            if (result.success) {
                allTransactions = result.transactions;
                leftColumnTransactions = result.transactions;
                
                // Update title based on filter
                if (transactionTypeFilter.value === 'uncategorized') {
                    leftColumnTitle.textContent = 'Uncategorized Transactions';
                } else {
                    leftColumnTitle.textContent = 'Filtered Transactions';
                }
                
                renderLeftColumnTransactions();
                updateTransactionCount();
                
                // Clear selections
                selectedLeftTransactions.clear();
                selectedRightTransactions.clear();
                
            } else {
                uncategorizedTransactionsList.innerHTML = `<div class="no-data">Error: ${result.error}</div>`;
            }
            
        } catch (error) {
            uncategorizedTransactionsList.innerHTML = `<div class="no-data">Error loading transactions: ${error.message}</div>`;
        } finally {
            btnLoadTransactions.disabled = false;
            btnLoadTransactions.textContent = '🔍 Load Transactions';
        }
    }
    
    function clearFilters() {
        transactionTypeFilter.value = 'all';
        categoryFilter.value = 'all';
        specificCategoryFilter.value = '';
        searchText.value = '';
        minAmount.value = '';
        maxAmount.value = '';
        
        // Reset date filters to current month
        setDefaultDateFilters();
        
        uncategorizedTransactionsList.innerHTML = '<div class="no-data">Click "Load Transactions" to begin</div>';
        categorizedTransactionsList.innerHTML = '<div class="no-data">Select a category to view transactions</div>';
        viewCategorySelect.value = '';
        
        updateTransactionCount();
    }
    
    function updateTransactionCount() {
        if (leftColumnTransactions.length > 0) {
            transactionCount.textContent = `${leftColumnTransactions.length} transactions loaded`;
        } else {
            transactionCount.textContent = '';
        }
    }
    
    function renderLeftColumnTransactions() {
        if (leftColumnTransactions.length === 0) {
            uncategorizedTransactionsList.innerHTML = '<div class="no-data">No transactions match your filters</div>';
            return;
        }
        
        uncategorizedTransactionsList.innerHTML = leftColumnTransactions.map(transaction => 
            renderTransactionItem(transaction, 'left')
        ).join('');
        
        // Add event listeners for checkboxes and clicks
        addTransactionEventListeners('left');
    }
    
    function renderRightColumnTransactions() {
        if (rightColumnTransactions.length === 0) {
            categorizedTransactionsList.innerHTML = '<div class="no-data">No transactions found for this category</div>';
            return;
        }
        
        categorizedTransactionsList.innerHTML = rightColumnTransactions.map(transaction => 
            renderTransactionItem(transaction, 'right')
        ).join('');
        
        // Add event listeners for checkboxes and clicks
        addTransactionEventListeners('right');
    }
    
    function renderTransactionItem(transaction, side) {
        const isSelected = side === 'left' 
            ? selectedLeftTransactions.has(transaction.id)
            : selectedRightTransactions.has(transaction.id);
            
        const amountClass = transaction.type === 'withdrawal' ? 'withdrawal' : 'deposit';
        const amountPrefix = transaction.type === 'withdrawal' ? '-' : '+';
        
        return `
            <div class="transaction-item ${isSelected ? 'selected' : ''}" 
                 data-transaction-id="${transaction.id}" 
                 data-side="${side}"
                 data-category="${transaction.category || ''}"
                 draggable="true">
                <div class="drag-handle">⋮⋮</div>
                <input type="checkbox" class="transaction-checkbox" ${isSelected ? 'checked' : ''} 
                       data-transaction-id="${transaction.id}" data-side="${side}">
                <div class="transaction-content">
                    <div class="transaction-header">
                        <div class="transaction-description" title="${transaction.description}">
                            ${transaction.description}
                        </div>
                        <div class="transaction-amount ${amountClass}">
                            ${amountPrefix}${Math.abs(transaction.amount).toFixed(2)} ${transaction.currency}
                        </div>
                    </div>
                    <div class="transaction-meta">
                        <div class="transaction-destination" title="${transaction.destinationName}">
                            📍 ${transaction.destinationName}
                        </div>
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <span class="transaction-type ${transaction.type}">${transaction.type}</span>
                            ${transaction.category ? `<span class="transaction-category">${transaction.category}</span>` : ''}
                            <span class="transaction-date">${new Date(transaction.date).toLocaleDateString()}</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function addTransactionEventListeners(side) {
        const container = side === 'left' ? uncategorizedTransactionsList : categorizedTransactionsList;
        
        // Checkbox change events
        container.querySelectorAll('.transaction-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                e.stopPropagation();
                const transactionId = e.target.dataset.transactionId;
                const targetSide = e.target.dataset.side;
                
                if (e.target.checked) {
                    if (targetSide === 'left') {
                        selectedLeftTransactions.add(transactionId);
                    } else {
                        selectedRightTransactions.add(transactionId);
                    }
                } else {
                    if (targetSide === 'left') {
                        selectedLeftTransactions.delete(transactionId);
                    } else {
                        selectedRightTransactions.delete(transactionId);
                    }
                }
                
                updateTransactionItemSelection(transactionId, targetSide, e.target.checked);
                updateSelectionButtons();
            });
        });
        
        // Transaction item click events (toggle selection)
        container.querySelectorAll('.transaction-item').forEach(item => {
            item.addEventListener('click', (e) => {
                if (e.target.type === 'checkbox') return; // Skip if clicking checkbox directly
                if (e.target.classList.contains('drag-handle')) return; // Skip if clicking drag handle
                
                const transactionId = item.dataset.transactionId;
                const targetSide = item.dataset.side;
                const checkbox = item.querySelector('.transaction-checkbox');
                
                checkbox.checked = !checkbox.checked;
                checkbox.dispatchEvent(new Event('change'));
            });
            
            // Drag and Drop Events
            item.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', JSON.stringify({
                    transactionId: item.dataset.transactionId,
                    side: item.dataset.side,
                    category: item.dataset.category,
                    description: item.querySelector('.transaction-description').textContent,
                    amount: item.querySelector('.transaction-amount').textContent
                }));
                
                item.classList.add('dragging');
                showCategoryGrid();
                createDragHelper(e);
            });
            
            item.addEventListener('dragend', (e) => {
                item.classList.remove('dragging');
                hideCategoryGrid();
                removeDragHelper();
                clearDropZoneStates();
            });
        });
        
        // Drop zone events for the container
        container.addEventListener('dragover', (e) => {
            e.preventDefault();
            
            try {
                const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
                const isValidDrop = validateDropOperation(dragData, side);
                
                if (isValidDrop) {
                    container.classList.add('drag-over');
                    container.classList.remove('drag-over-invalid');
                    container.classList.add('active');
                } else {
                    container.classList.add('drag-over-invalid');
                    container.classList.remove('drag-over');
                    container.classList.add('invalid');
                }
            } catch (e) {
                // Data might not be available during dragover in some browsers
            }
        });
        
        container.addEventListener('dragleave', (e) => {
            if (!container.contains(e.relatedTarget)) {
                container.classList.remove('drag-over', 'drag-over-invalid');
                container.classList.remove('active', 'invalid');
            }
        });
        
        container.addEventListener('drop', async (e) => {
            e.preventDefault();
            
            try {
                const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
                await handleTransactionDrop(dragData, side);
            } catch (error) {
                console.error('Drop error:', error);
                showToast('Error processing drop: ' + error.message, 'error');
            }
            
            clearDropZoneStates();
        });
    }
    
    function updateTransactionItemSelection(transactionId, side, isSelected) {
        const container = side === 'left' ? uncategorizedTransactionsList : categorizedTransactionsList;
        const item = container.querySelector(`[data-transaction-id="${transactionId}"]`);
        
        if (item) {
            if (isSelected) {
                item.classList.add('selected');
            } else {
                item.classList.remove('selected');
            }
        }
    }
    
    function updateSelectionButtons() {
        const leftCount = selectedLeftTransactions.size;
        const rightCount = selectedRightTransactions.size;
        
        // Update button text with counts
        btnSelectAllLeft.innerHTML = leftCount > 0 ? `☑️ Selected (${leftCount})` : '☑️ Select All';
        btnSelectAllRight.innerHTML = rightCount > 0 ? `☑️ Selected (${rightCount})` : '☑️ Select All';
        
        // Enable/disable action buttons
        btnAssignCategory.disabled = leftCount === 0;
        btnReassignCategory.disabled = rightCount === 0;
        btnRemoveCategory.disabled = rightCount === 0;
    }
    
    function selectAllTransactions(side) {
        const transactions = side === 'left' ? leftColumnTransactions : rightColumnTransactions;
        const selectedSet = side === 'left' ? selectedLeftTransactions : selectedRightTransactions;
        
        transactions.forEach(transaction => {
            selectedSet.add(transaction.id);
        });
        
        // Re-render to update checkboxes
        if (side === 'left') {
            renderLeftColumnTransactions();
        } else {
            renderRightColumnTransactions();
        }
        
        updateSelectionButtons();
    }
    
    function deselectAllTransactions(side) {
        const selectedSet = side === 'left' ? selectedLeftTransactions : selectedRightTransactions;
        selectedSet.clear();
        
        // Re-render to update checkboxes
        if (side === 'left') {
            renderLeftColumnTransactions();
        } else {
            renderRightColumnTransactions();
        }
        
        updateSelectionButtons();
    }
    
    async function assignCategoryToSelected() {
        const categoryName = assignCategorySelect.value;
        
        if (!categoryName) {
            alert('Please select a category to assign');
            return;
        }
        
        if (selectedLeftTransactions.size === 0) {
            alert('Please select transactions to assign categories to');
            return;
        }
        
        const transactionIds = Array.from(selectedLeftTransactions);
        
        btnAssignCategory.disabled = true;
        btnAssignCategory.textContent = '⏳ Assigning...';
        
        try {
            const response = await fetch('/api/transactions/update-categories', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    transactionIds: transactionIds,
                    categoryName: categoryName
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                alert(`✅ Successfully updated ${result.successCount} transactions`);
                
                // Clear selections and reload
                selectedLeftTransactions.clear();
                loadTransactions();
                
                // If viewing a category, refresh it
                if (viewCategorySelect.value) {
                    loadCategorizedTransactions();
                }
                
            } else {
                alert(`Error: ${result.error}`);
            }
            
        } catch (error) {
            alert(`Error: ${error.message}`);
        } finally {
            btnAssignCategory.disabled = false;
            btnAssignCategory.textContent = '➡️ Assign Category';
        }
    }
    
    async function reassignCategoryToSelected() {
        const categoryName = reassignCategorySelect.value;
        
        if (!categoryName) {
            alert('Please select a new category');
            return;
        }
        
        if (selectedRightTransactions.size === 0) {
            alert('Please select transactions to reassign');
            return;
        }
        
        const transactionIds = Array.from(selectedRightTransactions);
        
        btnReassignCategory.disabled = true;
        btnReassignCategory.textContent = '⏳ Reassigning...';
        
        try {
            const response = await fetch('/api/transactions/update-categories', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    transactionIds: transactionIds,
                    categoryName: categoryName
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                alert(`✅ Successfully reassigned ${result.successCount} transactions`);
                
                // Clear selections and reload
                selectedRightTransactions.clear();
                loadCategorizedTransactions();
                
            } else {
                alert(`Error: ${result.error}`);
            }
            
        } catch (error) {
            alert(`Error: ${error.message}`);
        } finally {
            btnReassignCategory.disabled = false;
            btnReassignCategory.textContent = '🔄 Reassign';
        }
    }
    
    async function removeCategoryFromSelected() {
        if (selectedRightTransactions.size === 0) {
            alert('Please select transactions to remove categories from');
            return;
        }
        
        if (!confirm(`Remove categories from ${selectedRightTransactions.size} selected transactions?`)) {
            return;
        }
        
        const transactionIds = Array.from(selectedRightTransactions);
        
        btnRemoveCategory.disabled = true;
        btnRemoveCategory.textContent = '⏳ Removing...';
        
        try {
            const response = await fetch('/api/transactions/remove-categories', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    transactionIds: transactionIds
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                alert(`✅ Successfully removed categories from ${result.successCount} transactions`);
                
                // Clear selections and reload
                selectedRightTransactions.clear();
                loadCategorizedTransactions();
                
            } else {
                alert(`Error: ${result.error}`);
            }
            
        } catch (error) {
            alert(`Error: ${error.message}`);
        } finally {
            btnRemoveCategory.disabled = false;
            btnRemoveCategory.textContent = '❌ Remove Category';
        }
    }
    
    async function loadCategorizedTransactions() {
        const selectedCategory = viewCategorySelect.value;
        
        if (!selectedCategory) {
            categorizedTransactionsList.innerHTML = '<div class="no-data">Select a category to view transactions</div>';
            rightColumnTransactions = [];
            selectedRightTransactions.clear();
            updateSelectionButtons();
            return;
        }
        
        categorizedTransactionsList.innerHTML = '<div class="loading-state">Loading categorized transactions...</div>';
        
        try {
            const params = new URLSearchParams({
                type: 'all',
                hasCategory: 'yes',
                categoryName: selectedCategory,
                limit: 500
            });
            
            // Add date filters if set
            if (dateFrom.value) {
                params.append('dateFrom', dateFrom.value);
            }
            
            if (dateTo.value) {
                params.append('dateTo', dateTo.value);
            }
            
            const response = await fetch(`/api/transactions/filter?${params}`);
            const result = await response.json();
            
            if (result.success) {
                rightColumnTransactions = result.transactions;
                selectedRightTransactions.clear();
                renderRightColumnTransactions();
                updateSelectionButtons();
            } else {
                categorizedTransactionsList.innerHTML = `<div class="no-data">Error: ${result.error}</div>`;
            }
            
        } catch (error) {
            categorizedTransactionsList.innerHTML = `<div class="no-data">Error loading transactions: ${error.message}</div>`;
        }
    }

    async function loadFailedTransactions() {
        try {
            const response = await fetch('/api/failed-transactions');
            const result = await response.json();
            
            if (result.success) {
                renderFailedTransactions(result.failedTransactions);
            } else {
                console.error('Failed to load failed transactions:', result.error);
            }
        } catch (error) {
            console.error('Error loading failed transactions:', error);
        }
    }

    async function cleanupFailedTransactions() {
        if (confirm('Clean up old and duplicate failed transactions? This will remove transactions older than 7 days and duplicates.')) {
            try {
                const response = await fetch('/api/failed-transactions/cleanup', { method: 'POST' });
                const result = await response.json();
                
                if (result.success) {
                    alert('Failed transactions cleaned up successfully!');
                    loadFailedTransactions(); // Refresh the list
                } else {
                    alert('Error: ' + result.error);
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
    }

    async function loadWordMappings() {
        try {
            const response = await fetch('/api/word-mappings');
            const result = await response.json();
            
            if (result.success) {
                renderWordMappings(result.mappings);
            } else {
                console.error('Failed to load word mappings:', result.error);
            }
        } catch (error) {
            console.error('Error loading word mappings:', error);
        }
    }

    async function addWordMapping() {
        const from = mappingFrom.value.trim();
        const to = mappingTo.value.trim();
        
        if (!from || !to) {
            alert('Please fill in both fields');
            return;
        }
        
        try {
            const response = await fetch('/api/word-mappings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    fromWord: from,
                    toWord: to
                })
            });
            
            const result = await response.json();
            if (result.success) {
                mappingFrom.value = '';
                mappingTo.value = '';
                loadWordMappings(); // Refresh the list
                alert('Word mapping added successfully!');
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            alert('Error: ' + error.message);
        }
    }

    function renderFailedTransactions(transactions) {
        if (!transactions || transactions.length === 0) {
            failedTransactionsDiv.innerHTML = '<div class="no-data">No failed transactions found</div>';
            updateCollapsibleCounts();
            return;
        }

        failedTransactionsDiv.innerHTML = transactions.map(transaction => `
            <div class="failed-transaction">
                <div class="transaction-content">
                    <div class="transaction-meta">Failed on ${new Date(transaction.created).toLocaleString()}</div>
                    <div class="transaction-text">${transaction.description}</div>
                    <div style="font-size: 14px; color: #666;">Destination: ${transaction.destinationName}</div>
                </div>
                <div class="mapping-inputs">
                    <input type="text" placeholder="Replace word" class="mapping-input-from" data-transaction-id="${transaction.id}">
                    <span>→</span>
                    <input type="text" placeholder="With word" class="mapping-input-to" data-transaction-id="${transaction.id}">
                    <button class="btn btn-success btn-small" onclick="addMappingFromTransaction('${transaction.id}')">
                        Add Mapping
                    </button>
                </div>
            </div>
        `).join('');
        updateCollapsibleCounts();
    }

    function renderWordMappings(mappings) {
        if (!mappings || mappings.length === 0) {
            wordMappingsDiv.innerHTML = '<div class="no-data">No word mappings defined</div>';
            updateCollapsibleCounts();
            return;
        }

        wordMappingsDiv.innerHTML = mappings.map(mapping => `
            <div class="word-mapping" id="mapping-${mapping.from}">
                <div class="mapping-content">
                    <div class="mapping-meta">Word Mapping</div>
                    <div class="mapping-text">"${mapping.from}" → "${mapping.to}"</div>
                </div>
                <div style="display: flex; gap: 5px;">
                    <button class="btn btn-primary btn-small" onclick="editWordMapping('${mapping.from}', '${mapping.to}')">
                        ✏️ Edit
                    </button>
                    <button class="btn btn-warning btn-small" onclick="removeWordMapping('${mapping.from}')">
                        🗑️ Remove
                    </button>
                </div>
            </div>
        `).join('');
        updateCollapsibleCounts();
    }

    window.editWordMapping = function(fromWord, toWord) {
        mappingFrom.value = fromWord;
        mappingTo.value = toWord;
        mappingFrom.focus();
        
        // Show a message that they can edit and save
        alert(`Editing mapping: "${fromWord}" → "${toWord}"\n\nYou can now modify the values and click "Add Mapping" to update.`);
    };

    window.addMappingFromTransaction = function(transactionId) {
        const fromInput = document.querySelector(`.mapping-input-from[data-transaction-id="${transactionId}"]`);
        const toInput = document.querySelector(`.mapping-input-to[data-transaction-id="${transactionId}"]`);
        
        const from = fromInput.value.trim();
        const to = toInput.value.trim();
        
        if (!from || !to) {
            alert('Please fill in both mapping fields');
            return;
        }
        
        // Set the values in the main form
        mappingFrom.value = from;
        mappingTo.value = to;
        
        // Trigger the add mapping
        addWordMapping();
    };

    window.removeWordMapping = async function(fromWord) {
        if (confirm(`Remove mapping for "${fromWord}"?`)) {
            try {
                const response = await fetch(`/api/word-mappings/${encodeURIComponent(fromWord)}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                if (result.success) {
                    loadWordMappings(); // Refresh the list
                } else {
                    alert('Error: ' + result.error);
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
    };

    // General Settings functions
    async function saveGeneralSettings() {
        const config = {
            skipDeposits: autoSkipDeposits.checked
        };
        
        try {
            const response = await fetch('/api/auto-categorization/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ config })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('General settings saved successfully!');
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            alert('Error: ' + error.message);
        }
    }

    // Auto-categorization functions
    async function loadAutoCategorizationConfig() {
        try {
            const response = await fetch('/api/auto-categorization/config');
            const result = await response.json();
            
            if (result.success) {
                const config = result.config;
                autoEnabled.checked = config.enabled;
                autoSkipDeposits.checked = config.skipDeposits;
                autoNativeCurrency.value = config.nativeCurrency;
                autoHomeCountry.value = config.homeCountry;
                autoForeignCategory.value = config.foreignCategory;
                renderForeignKeywords(config.foreignKeywords);
            } else {
                console.error('Failed to load auto-categorization config:', result.error);
            }
        } catch (error) {
            console.error('Error loading auto-categorization config:', error);
        }
    }

    async function saveAutoCategorizationConfig() {
        const config = {
            enabled: autoEnabled.checked,
            skipDeposits: autoSkipDeposits.checked,
            nativeCurrency: autoNativeCurrency.value.trim().toUpperCase(),
            homeCountry: autoHomeCountry.value.trim(),
            foreignCategory: autoForeignCategory.value.trim()
        };
        
        if (!config.nativeCurrency || !config.homeCountry || !config.foreignCategory) {
            alert('Please fill in all configuration fields');
            return;
        }
        
        try {
            const response = await fetch('/api/auto-categorization/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ config })
            });
            
            const result = await response.json();
            if (result.success) {
                alert('Auto-categorization config saved successfully!');
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            alert('Error: ' + error.message);
        }
    }

    async function saveForeignKeywords() {
        const keywords = foreignKeywordsInput.value.trim().split(',').map(keyword => keyword.trim());
        
        if (keywords.length === 0) {
            alert('Please enter at least one keyword');
            return;
        }
        
        try {
            const response = await fetch('/api/auto-categorization/keywords', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ keywords })
            });
            
            const result = await response.json();
            if (result.success) {
                foreignKeywordsInput.value = '';
                loadAutoCategorizationConfig(); // Refresh the list
                alert('Foreign keywords saved successfully!');
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            alert('Error: ' + error.message);
        }
    }

    function renderForeignKeywords(keywords) {
        if (!keywords || keywords.length === 0) {
            foreignKeywordsDiv.innerHTML = '<div class="no-data">No foreign keywords defined</div>';
            foreignKeywordsInput.value = '';
            updateCollapsibleCounts();
            return;
        }

        // Display as comma-separated list in input field
        foreignKeywordsInput.value = keywords.join(', ');
        
        // Display as read-only list in collapsible section
        foreignKeywordsDiv.innerHTML = `
            <div class="word-mapping">
                <div class="mapping-content">
                    <div class="mapping-meta">Foreign Keywords (${keywords.length} total)</div>
                    <div class="mapping-text">${keywords.join(', ')}</div>
                </div>
                <button class="btn btn-warning btn-small" onclick="clearForeignKeywords()">
                    🗑️ Clear All
                </button>
            </div>
        `;
        updateCollapsibleCounts();
    }

    window.clearForeignKeywords = function() {
        if (confirm('Clear all foreign keywords?')) {
            foreignKeywordsInput.value = '';
            saveForeignKeywords();
        }
    };

    // Category mapping functions
    async function loadCategoryMappings() {
        try {
            const response = await fetch('/api/category-mappings');
            const result = await response.json();
            
            if (result.success) {
                renderCategoryMappings(result.mappings);
            } else {
                console.error('Failed to load category mappings:', result.error);
            }
        } catch (error) {
            console.error('Error loading category mappings:', error);
        }
    }

    function showAddCategoryMappingForm() {
        addCategoryMappingForm.style.display = 'block';
        btnAddCategoryMapping.style.display = 'none';
        mappingName.focus();
    }

    function hideAddCategoryMappingForm() {
        addCategoryMappingForm.style.display = 'none';
        btnAddCategoryMapping.style.display = 'inline-block';
        
        // Clear form
        mappingName.value = '';
        mappingTargetCategory.value = '';
        mappingKeywords.value = '';
        
        // Reset editing state
        window.editingMappingId = null;
        btnSaveCategoryMapping.textContent = '💾 Save Mapping';
    }

    async function saveCategoryMapping() {
        const mappingData = {
            name: mappingName.value.trim(),
            targetCategory: mappingTargetCategory.value.trim(),
            keywords: mappingKeywords.value.trim()
        };
        
        if (!mappingData.name || !mappingData.targetCategory || !mappingData.keywords) {
            alert('Please fill in all fields');
            return;
        }
        
        try {
            let response;
            if (window.editingMappingId) {
                // Update existing mapping
                response = await fetch(`/api/category-mappings/${window.editingMappingId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(mappingData)
                });
            } else {
                // Create new mapping
                response = await fetch('/api/category-mappings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(mappingData)
                });
            }
            
            const result = await response.json();
            if (result.success) {
                hideAddCategoryMappingForm();
                loadCategoryMappings(); // Refresh the list
                alert(window.editingMappingId ? 'Category mapping updated successfully!' : 'Category mapping added successfully!');
                
                // Reset editing state
                window.editingMappingId = null;
                btnSaveCategoryMapping.textContent = '💾 Save Mapping';
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            alert('Error: ' + error.message);
        }
    }

    async function toggleCategoryMapping(id, enabled) {
        try {
            const response = await fetch(`/api/category-mappings/${id}/toggle`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ enabled })
            });
            
            const result = await response.json();
            if (result.success) {
                loadCategoryMappings(); // Refresh the list
            } else {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            alert('Error: ' + error.message);
        }
    }

    async function deleteCategoryMapping(id, name) {
        if (confirm(`Delete category mapping "${name}"?`)) {
            try {
                const response = await fetch(`/api/category-mappings/${id}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                if (result.success) {
                    loadCategoryMappings(); // Refresh the list
                } else {
                    alert('Error: ' + result.error);
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
    }

    function renderCategoryMappings(mappings) {
        if (!mappings || mappings.length === 0) {
            categoryMappingsList.innerHTML = '<div class="no-data">No category mappings defined. Click "➕ Add New Category Mapping" to create your first rule.</div>';
            updateCollapsibleCounts();
            return;
        }

        categoryMappingsList.innerHTML = mappings.map(mapping => {
            const keywordsString = Array.isArray(mapping.keywords) ? mapping.keywords.join(', ') : '';
            const keywordCount = Array.isArray(mapping.keywords) ? mapping.keywords.length : 0;
            
            return `
                <div class="category-mapping ${!mapping.enabled ? 'disabled' : ''}">
                    <div class="category-mapping-content">
                        <div class="category-mapping-header">
                            <span class="category-mapping-name">${mapping.name}</span>
                            <span class="category-mapping-category">${mapping.targetCategory}</span>
                        </div>
                        <div class="category-mapping-keywords">
                            <strong>Keywords:</strong> ${keywordsString}
                        </div>
                        <div class="category-mapping-stats">
                            ${keywordCount} keywords • Created: ${new Date(mapping.created).toLocaleDateString()}
                            ${mapping.updated ? ` • Updated: ${new Date(mapping.updated).toLocaleDateString()}` : ''}
                        </div>
                    </div>
                    <div class="category-mapping-actions">
                        <label class="toggle-switch">
                            <input type="checkbox" ${mapping.enabled ? 'checked' : ''} 
                                   onchange="toggleCategoryMapping('${mapping.id}', this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                        <button class="btn btn-primary btn-small" onclick="editCategoryMapping('${mapping.id}', '${mapping.name}', '${mapping.targetCategory}', '${keywordsString}')">
                            ✏️ Edit
                        </button>
                        <button class="btn btn-danger btn-small" onclick="deleteCategoryMapping('${mapping.id}', '${mapping.name}')">
                            🗑️
                        </button>
                    </div>
                </div>
            `;
        }).join('');
        updateCollapsibleCounts();
    }

    window.toggleCategoryMapping = toggleCategoryMapping;
    window.deleteCategoryMapping = deleteCategoryMapping;

    window.editCategoryMapping = function(id, name, targetCategory, keywords) {
        // Fill the form with existing values
        mappingName.value = name;
        mappingTargetCategory.value = targetCategory;
        mappingKeywords.value = keywords;
        
        // Show the form
        showAddCategoryMappingForm();
        
        // Store the ID for updating instead of creating
        window.editingMappingId = id;
        
        // Change button text
        btnSaveCategoryMapping.textContent = '💾 Update Mapping';
        
        alert(`Editing: "${name}"\n\nModify the values and click "Update Mapping" to save changes.`);
    };

    // Batch job control functions
    window.pauseBatchJob = async function(batchJobId) {
        if (confirm('Pause this batch job?')) {
            try {
                const response = await fetch(`/api/batch-jobs/${batchJobId}/pause`, {
                    method: 'POST'
                });
                const result = await response.json();
                if (!result.success) {
                    alert('Error: ' + result.error);
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
    };

    window.resumeBatchJob = async function(batchJobId) {
        try {
            const response = await fetch(`/api/batch-jobs/${batchJobId}/resume`, {
                method: 'POST'
            });
            const result = await response.json();
            if (!result.success) {
                alert('Error: ' + result.error);
            }
        } catch (error) {
            alert('Error: ' + error.message);
        }
    };

    window.cancelBatchJob = async function(batchJobId) {
        if (confirm('Cancel this batch job? This action cannot be undone.')) {
            try {
                const response = await fetch(`/api/batch-jobs/${batchJobId}/cancel`, {
                    method: 'POST'
                });
                const result = await response.json();
                if (!result.success) {
                    alert('Error: ' + result.error);
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
    };

    function getStatusColor(status) {
        switch (status) {
            case 'running': return '#007bff';
            case 'paused': return '#ffc107';
            case 'finished': return '#28a745';
            case 'cancelled': return '#dc3545';
            default: return '#6c757d';
        }
    }

    // Socket event handlers
    socket.on('jobs', jobs => {
        console.log('jobs', jobs);
        renderJobs(jobs);
    });

    socket.on('batch jobs', batchJobs => {
        console.log('batch jobs', batchJobs);
        renderBatchJobs(batchJobs);
    });

    socket.on('job created', e => {
        console.log('job created', e);
        const element = document.createElement('div');
        element.innerHTML = renderJob(e.job);
        mount.prepend(element);
    });

    socket.on('job updated', e => {
        console.log('job updated', e);
        const element = document.createElement('div');
        element.innerHTML = renderJob(e.job);
        const oldElement = document.querySelector(`[data-job-id="${e.job.id}"]`);
        if (oldElement) {
            oldElement.before(element);
            oldElement.remove();
        }
    });

    socket.on('batch job created', e => {
        console.log('batch job created', e);
        const element = document.createElement('div');
        element.innerHTML = renderBatchJob(e.batchJob);
        batchMount.prepend(element);
    });

    socket.on('batch job updated', e => {
        console.log('batch job updated', e);
        const element = document.createElement('div');
        element.innerHTML = renderBatchJob(e.batchJob);
        const oldElement = document.querySelector(`[data-batch-job-id="${e.batchJob.id}"]`);
        if (oldElement) {
        oldElement.before(element);
        oldElement.remove();
        }

        // Re-enable buttons when batch job finishes
        if (e.batchJob.status === 'finished') {
            btnProcessUncategorized.disabled = false;
            btnProcessAll.disabled = false;
        }
    });

    function renderJobs(jobs) {
        mount.innerHTML = '';
        jobs.sort((a, b) => new Date(b.created) - new Date(a.created));
        jobs.forEach(job => {
            const element = document.createElement('div');
            element.innerHTML = renderJob(job);
            mount.appendChild(element);
        });
    }

    function renderBatchJobs(batchJobs) {
        batchMount.innerHTML = '';
        batchJobs.sort((a, b) => new Date(b.created) - new Date(a.created));
        batchJobs.forEach(batchJob => {
            const element = document.createElement('div');
            element.innerHTML = renderBatchJob(batchJob);
            batchMount.appendChild(element);
        });
    }

    const renderJob = (job) => {
        return `<article class="job" data-job-id="${job.id}">
            <div><strong>ID:</strong> <span>${job.id}</span></div>
            <div><strong>Status:</strong> <span>${job.status}</span></div>
            <div><strong>Created:</strong>
                <time>${Intl.DateTimeFormat(undefined, {
                    dateStyle: 'medium',
                    timeStyle: 'medium'
                }).format(new Date(job.created))}</time>
            </div>
            <div><strong>Destination name:</strong> <span>${job.data?.destinationName || ''}</span></div>
            <div><strong>Description:</strong> <span>${job.data?.description || ''}</span>
            <div><strong>Guessed category:</strong> <span>${job.data?.category ? job.data.category : '<em>Not yet classified</em>'}</span>
            </div>
            ${job.data?.autoRule ? `<div><strong>Auto-categorized:</strong> 
                <span style="color: ${job.data.autoRule === 'category_mapping' ? '#007bff' : '#28a745'}; font-weight: bold;">
                    ${job.data.autoRule === 'category_mapping' ? '🗂️' : '✅'} ${job.data.autoRule}
                </span>
            </div>` : ''}
            ${ job.data?.prompt ? `<div><strong>Prompt:</strong><br>
                <details>
                    <summary>Show</summary>
                    <pre>${job.data.prompt}</pre>
                </details>
            </div>` : ''}
            ${ job.data?.response ? `<div><strong>Open AI's response:</strong>
                 <details>
                    <summary>Show</summary>
                    <pre>${job.data.response}</pre>
                 </details>
            </div>` : ''}
        </article>`
    }

    const renderBatchJob = (batchJob) => {
        const progress = batchJob.totalCount > 0 ? (batchJob.processedCount / batchJob.totalCount) * 100 : 0;
        const progressText = `${batchJob.processedCount}/${batchJob.totalCount}`;
        
        // Control buttons based on status
        let controlButtons = '';
        if (batchJob.status === 'running') {
            controlButtons = `
                <button class="btn btn-warning btn-small" onclick="pauseBatchJob('${batchJob.id}')">⏸️ Pause</button>
                <button class="btn btn-danger btn-small" onclick="cancelBatchJob('${batchJob.id}')">❌ Cancel</button>
            `;
        } else if (batchJob.status === 'paused') {
            controlButtons = `
                <button class="btn btn-success btn-small" onclick="resumeBatchJob('${batchJob.id}')">▶️ Resume</button>
                <button class="btn btn-danger btn-small" onclick="cancelBatchJob('${batchJob.id}')">❌ Cancel</button>
            `;
        }
        
        return `<article class="batch-job ${batchJob.status}" data-batch-job-id="${batchJob.id}">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div>
                    <strong>Batch Job:</strong> ${batchJob.type === 'uncategorized' ? 'Process Uncategorized' : 'Process All Transactions'}
                    <span style="margin-left: 10px; padding: 3px 8px; background: ${getStatusColor(batchJob.status)}; color: white; border-radius: 3px; font-size: 12px;">
                        ${batchJob.status.toUpperCase()}
                    </span>
                </div>
                <div style="display: flex; gap: 5px;">
                    ${controlButtons}
                </div>
            </div>
            <div><strong>Started:</strong>
                <time>${Intl.DateTimeFormat(undefined, {
                    dateStyle: 'medium',
                    timeStyle: 'medium'
                }).format(new Date(batchJob.created))}</time>
            </div>
            ${batchJob.finishedAt ? `<div><strong>Finished:</strong>
                <time>${Intl.DateTimeFormat(undefined, {
                    dateStyle: 'medium',
                    timeStyle: 'medium'
                }).format(new Date(batchJob.finishedAt))}</time>
            </div>` : ''}
            ${batchJob.pausedAt ? `<div><strong>Paused:</strong>
                <time>${Intl.DateTimeFormat(undefined, {
                    dateStyle: 'medium',
                    timeStyle: 'medium'
                }).format(new Date(batchJob.pausedAt))}</time>
            </div>` : ''}
            ${batchJob.cancelledAt ? `<div><strong>Cancelled:</strong>
                <time>${Intl.DateTimeFormat(undefined, {
                    dateStyle: 'medium',
                    timeStyle: 'medium'
                }).format(new Date(batchJob.cancelledAt))}</time>
            </div>` : ''}
            
            <div class="progress-bar">
                <div class="progress-bar-fill" style="width: ${progress}%">
                    ${progress.toFixed(1)}% (${progressText})
                </div>
            </div>
            
            <div class="stats">
                <div class="stat">
                    <div class="stat-value">${batchJob.totalCount}</div>
                    <div class="stat-label">Total</div>
                </div>
                <div class="stat">
                    <div class="stat-value">${batchJob.processedCount}</div>
                    <div class="stat-label">Processed</div>
                </div>
                <div class="stat">
                    <div class="stat-value">${batchJob.successCount}</div>
                    <div class="stat-label">Success</div>
                </div>
                <div class="stat">
                    <div class="stat-value">${batchJob.errorCount}</div>
                    <div class="stat-label">Errors</div>
                </div>
            </div>
            
            ${batchJob.errors && batchJob.errors.length > 0 ? `
                <details>
                    <summary>Show Errors (${batchJob.errors.length})</summary>
                    <div class="errors">
                        ${batchJob.errors.map(error => `<div class="error-item">${error}</div>`).join('')}
                    </div>
                </details>
            ` : ''}
        </article>`
    }

    // Collapsible interface functions
    window.toggleCollapsible = function(contentId) {
        console.log('toggleCollapsible called with:', contentId);
        try {
            const content = document.getElementById(contentId);
            if (!content) {
                console.error('Content element not found:', contentId);
                return;
            }
            
            const header = content.previousElementSibling;
            if (!header) {
                console.error('Header element not found for:', contentId);
                return;
            }
            
            const icon = header.querySelector('.expand-icon');
            if (!icon) {
                console.error('Icon element not found for:', contentId);
                return;
            }
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.classList.remove('expanded');
                icon.textContent = '🔽';
                console.log('Collapsed:', contentId);
            } else {
                content.classList.add('expanded');
                icon.classList.add('expanded');
                icon.textContent = '🔼';
                console.log('Expanded:', contentId);
            }
        } catch (error) {
            console.error('Error in toggleCollapsible:', error);
        }
    };

    // Update count displays
    function updateCollapsibleCounts() {
        try {
            // Update failed transactions count
            const failedTransactions = document.getElementById('failed-transactions');
            const failedCount = document.getElementById('failed-transactions-count');
            if (failedTransactions && failedCount) {
                failedCount.textContent = failedTransactions.children.length;
            }

            // Update word mappings count
            const wordMappings = document.getElementById('word-mappings');
            const wordCount = document.getElementById('word-mappings-count');
            if (wordMappings && wordCount) {
                wordCount.textContent = wordMappings.children.length;
            }

            // Update foreign keywords count
            const foreignKeywords = document.getElementById('foreign-keywords');
            const foreignCount = document.getElementById('foreign-keywords-count');
            if (foreignKeywords && foreignCount) {
                foreignCount.textContent = foreignKeywords.children.length;
            }

            // Update category mappings count
            const categoryMappings = document.getElementById('category-mappings-list');
            const categoryCount = document.getElementById('category-mappings-count');
            if (categoryMappings && categoryCount) {
                categoryCount.textContent = categoryMappings.children.length;
            }
            
            console.log('Counts updated successfully');
        } catch (error) {
            console.error('Error updating counts:', error);
        }
    }
    
    // Drag and Drop Helper Functions
    function showCategoryGrid() {
        const categoryGrid = document.getElementById('category-grid');
        if (!categoryGrid) return;
        
        // Clear existing categories
        categoryGrid.innerHTML = '';
        
        // Add "Remove Category" zone
        const removeCategoryZone = document.createElement('div');
        removeCategoryZone.className = 'category-drop-zone';
        removeCategoryZone.dataset.category = '';
        removeCategoryZone.innerHTML = '❌ Remove Category';
        removeCategoryZone.style.borderColor = '#dc3545';
        removeCategoryZone.style.color = '#dc3545';
        categoryGrid.appendChild(removeCategoryZone);
        
        // Add category zones
        availableCategories.forEach(category => {
            const categoryZone = document.createElement('div');
            categoryZone.className = 'category-drop-zone';
            categoryZone.dataset.category = category;
            categoryZone.innerHTML = `📁 ${category}`;
            categoryGrid.appendChild(categoryZone);
        });
        
        // Add event listeners to category zones
        categoryGrid.querySelectorAll('.category-drop-zone').forEach(zone => {
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('drag-over');
            });
            
            zone.addEventListener('dragleave', (e) => {
                zone.classList.remove('drag-over');
            });
            
            zone.addEventListener('drop', async (e) => {
                e.preventDefault();
                zone.classList.remove('drag-over');
                zone.classList.add('processing');
                
                try {
                    const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
                    const targetCategory = zone.dataset.category;
                    
                    if (targetCategory === '') {
                        // Remove category
                        await assignTransactionCategory(dragData.transactionId, null);
                    } else {
                        // Assign category
                        await assignTransactionCategory(dragData.transactionId, targetCategory);
                    }
                    
                    showToast(`✅ Transaction ${targetCategory ? 'categorized as "' + targetCategory + '"' : 'category removed'}`, 'success');
                    
                    // Refresh views
                    loadTransactions();
                    if (viewCategorySelect.value) {
                        loadCategorizedTransactions();
                    }
                    
                } catch (error) {
                    console.error('Category drop error:', error);
                    showToast('Error: ' + error.message, 'error');
                } finally {
                    zone.classList.remove('processing');
                }
            });
        });
        
        // Show the grid
        categoryGrid.classList.add('show');
    }
    
    function hideCategoryGrid() {
        const categoryGrid = document.getElementById('category-grid');
        if (categoryGrid) {
            categoryGrid.classList.remove('show');
        }
    }
    
    function validateDropOperation(dragData, targetSide) {
        // Allow dropping from any side to any side
        // Left side (uncategorized) - can remove categories or assign new ones
        // Right side (categorized) - can reassign categories or remove them
        
        if (targetSide === 'left') {
            // Dropping on left side means removing category
            return dragData.category !== ''; // Only allow if transaction has a category
        } else {
            // Dropping on right side means assigning current view category
            const currentCategory = viewCategorySelect.value;
            return currentCategory && currentCategory !== dragData.category; // Only allow if different category
        }
    }
    
    function createDragHelper(e) {
        const helper = document.createElement('div');
        helper.className = 'drag-helper';
        helper.id = 'drag-helper';
        helper.textContent = '🖱️ Drag to category';
        document.body.appendChild(helper);
        
        // Update position during drag
        document.addEventListener('dragover', updateDragHelper);
    }
    
    function updateDragHelper(e) {
        const helper = document.getElementById('drag-helper');
        if (helper) {
            helper.style.left = e.clientX + 'px';
            helper.style.top = e.clientY + 'px';
        }
    }
    
    function removeDragHelper() {
        const helper = document.getElementById('drag-helper');
        if (helper) {
            helper.remove();
        }
        document.removeEventListener('dragover', updateDragHelper);
    }
    
    function clearDropZoneStates() {
        // Clear all drop zone states
        document.querySelectorAll('.transaction-list').forEach(list => {
            list.classList.remove('drag-over', 'drag-over-invalid', 'active', 'invalid');
        });
        
        document.querySelectorAll('.category-drop-zone').forEach(zone => {
            zone.classList.remove('drag-over', 'processing');
        });
    }
    
    async function handleTransactionDrop(dragData, targetSide) {
        if (targetSide === 'left') {
            // Dropped on left side - remove category
            if (dragData.category) {
                await assignTransactionCategory(dragData.transactionId, null);
                showToast('✅ Category removed from transaction', 'success');
            } else {
                showToast('⚠️ Transaction already has no category', 'warning');
            }
        } else {
            // Dropped on right side - assign current view category
            const currentCategory = viewCategorySelect.value;
            if (currentCategory && currentCategory !== dragData.category) {
                await assignTransactionCategory(dragData.transactionId, currentCategory);
                showToast(`✅ Transaction categorized as "${currentCategory}"`, 'success');
            } else {
                showToast('⚠️ Cannot assign same category or no category selected', 'warning');
            }
        }
        
        // Refresh views
        loadTransactions();
        if (viewCategorySelect.value) {
            loadCategorizedTransactions();
        }
    }
    
    async function assignTransactionCategory(transactionId, categoryName) {
        if (categoryName === null) {
            // Remove category
            const response = await fetch('/api/transactions/remove-categories', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    transactionIds: [transactionId]
                })
            });
            
            const result = await response.json();
            if (!result.success) {
                throw new Error(result.error || 'Failed to remove category');
            }
        } else {
            // Assign category
            const response = await fetch('/api/transactions/update-categories', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    transactionIds: [transactionId],
                    categoryName: categoryName
                })
            });
            
            const result = await response.json();
            if (!result.success) {
                throw new Error(result.error || 'Failed to assign category');
            }
        }
    }
    
    function showToast(message, type = 'info') {
        // Create toast notification
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : type === 'warning' ? '#ffc107' : '#007bff'};
            color: ${type === 'warning' ? '#212529' : 'white'};
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10000;
            font-weight: bold;
            max-width: 300px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        `;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        // Animate in
        setTimeout(() => {
            toast.style.opacity = '1';
            toast.style.transform = 'translateX(0)';
        }, 10);
        
        // Remove after delay
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }, 4000);
    }
</script>
</body>
</html>